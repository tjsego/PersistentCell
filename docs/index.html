<!DOCTYPE html>
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no, user-scalable=no">
  	
<title>PRW</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-wEmeIV1mKuiNpC+IOBjI7aAzPcEZeedi5yW5f2yOq55WWLwNGmvvx4Um1vskeMj0" crossorigin="anonymous">
<script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
<link rel="stylesheet" href="https://pro.fontawesome.com/releases/v5.13.0/css/all.css">
<link rel="stylesheet" href="./style.css">

<script src="./artistoo.js"></script>

<!-- Model scripts -->
<script src="./configuration.js"></script>


<script>
"use strict"

let config = {
		field_size : [configJSON["len_1"],configJSON["len_2"]],
		conf : {
			torus : [true,true],					
			seed : 1,		
			T : configJSON["cpm_temperature"],			
			LAMBDA_V : [0,configJSON["cpm_area_v"]],					
			V : [0,configJSON["cpm_area_c"]],						
			LAMBDA_P : [0,configJSON["cpm_perim_v"]],
			P : [0,configJSON["cpm_perim_c"]]
		},
		simsettings : {
			NRCELLS : [1],					
			BURNIN : 0,
			RUNTIME : configJSON["max_time"],
			CANVASCOLOR : "eaecef",
			CELLCOLOR : ["CC0000"],	
			zoom : 3,							
			SAVEIMG : false,		
			STATSOUT : { browser: false, node: true },
			LOGRATE : 2
		}
	}

/*	---------------------------------- */

let sims = []
let model_config = configJSON[ "model_args" ]
let model_names = Object.keys( model_config )

// linking configuration parameters to the slider's ID in the html
let rangeMap = {
	"perim" : { key: 'P', position: 1},
	"T" : { key:'T', position: 'none'},
	"larea" : {key:'LAMBDA_V',position:1},
	"area" : {key:'V',position:1},
	"lper" :  {key:'LAMBDA_P',position:1}
}

let modelRangeMap = {
		"MODEL000" : {
			// none
		},
		"MODEL005" : {
			"ldir" : { constraint : "PersistenceConstraint", key: 'LAMBDA_DIR', position: 1 },
			"pper" : { constraint : "PersistenceConstraint", key: 'PERSIST', position: 1 },
			"dt" : { constraint : "PersistenceConstraint", key: 'DELTA_T', position: 1 }
		}
}



let trackMemory = 500, trackResolution = 10


function logStats(){
	let centroid = this.C.getStat( CPM.CentroidsWithTorusCorrection )[1]
	console.log( this.time + "," + seed + "," + centroid.join(",") )		
}

function drawOnTop(){

	// ========= draw direction vectors on top
	
	let pdc = this.C.getConstraint( "PersistenceConstraint" )
	let ctx = this.Cim.context(), zoom = this.conf["zoom"]
	ctx.strokeStyle="#000000"
	let prefdir = ( pdc.conf["LAMBDA_DIR"][ 1 ] > 0  ) || false
	ctx.beginPath()
	ctx.lineWidth = 2*zoom

	for( let i of this.C.cellIDs() ){
		
		// Only draw for cells that have a preferred direction.
		//if( i == 0 ) continue
		if( !prefdir ) continue

		
		function normalize( a ){
			let norm = 0
			for( let i = 0 ; i < a.length ; i ++ ){
				norm += a[i]*a[i]
			}
			norm = Math.sqrt(norm)
			let b = []
			for( let i = 0 ; i < a.length ; i ++ ){
				b.push( a[i] / norm )
			}
			return b
		}
		let cdir = normalize(pdc.celldirections[i])
		
		ctx.moveTo( 
			pdc.cellcentroidlists[i][0][0]*zoom,
			pdc.cellcentroidlists[i][0][1]*zoom)
		ctx.lineTo( (pdc.cellcentroidlists[i][0][0]+5*cdir[0])*zoom,
			(pdc.cellcentroidlists[i][0][1]+5*cdir[1])*zoom)
	}
	ctx.stroke()		
	
	
	document.getElementById("time").innerHTML = this.time
}

function drawBelow(){
	// draw Tracks
	const ctx = this.Cim.ctx
	ctx.globalAlpha = 0.8;
	ctx.strokeStyle="#0000EE"
	ctx.beginPath()
	ctx.lineWidth = 3
	const trace = this.centroids
	if( trace.length >= 2 ){
		let start = [trace[0][0]*this.Cim.zoom,trace[0][1]*this.Cim.zoom]
		ctx.moveTo( start[0],start[1] )
		for( let t = 1; t < trace.length; t++ ){
			let end = [trace[t][0]*this.Cim.zoom,trace[t][1]*this.Cim.zoom]
			if( ( Math.abs( start[0]-end[0] ) < Math.floor( this.C.extents[0]/2 ) ) && ( Math.abs( start[1]-end[1] ) < Math.floor( this.C.extents[1]/2 ) ) ){
				ctx.lineTo( end[0],end[1])
				ctx.moveTo( end[0],end[1])
				start = end.slice()
			} else {
				ctx.moveTo( end[0],end[1])
				start = end.slice()
			}
			//ctx.lineTo(  )
		}
	}

	ctx.stroke()
	ctx.globalAlpha = 1;	
}

function postMCSListener(){
	if( this.time % trackResolution == 0 ){
		const centr = this.C.getStat( CPM.CentroidsWithTorusCorrection )
		const cid = Object.keys( centr )[0]
		this.centroids.push( centr[cid] )
		while( this.centroids.length > (trackMemory/trackResolution) ){
			this.centroids.shift()
		}
	}
	
}

let custommethods = {
	drawOnTop : drawOnTop,
	drawBelow : drawBelow,
	logStats : logStats,
	postMCSListener : postMCSListener
}

function initialize(){

	sims = []
	
	for( let mi of model_names ){
		let simi = new CPM.Simulation( config, custommethods )
		simi.centroids = []
		simi.running = false
		sims.push( simi )
	}
	
	initCanvas()
	
	for( let i = 0; i < model_names.length; i++ ){
		let simi = sims[i]
		let mi = model_names[i]
		let pconstraint = new CPM.PersistenceConstraint( 
			{
				LAMBDA_DIR: [0,configJSON["model_args"][mi]["lambda_dir"]], 
				PERSIST: [0,configJSON["model_args"][mi]["persist"]],
				DELTA_T : [0,configJSON["model_args"][mi]["delta_t"]]
			} )
		simi.C.add( pconstraint )
	}
	
}


function step(){
	for( let i = 0; i < sims.length; i++ ){
		if( sims[i].running ) sims[i].step()
	}
	requestAnimationFrame( step )
}

function resetSim(){
	
	for( let i = 0; i < sims.length; i++ ){
		sims[i].running = false
	}
	initialize()
	sliderInput()
	setPlayPause()
}

function initCanvas(){

	for( let i = 0; i < model_names.length; i++ ){
		const name = model_names[i]
		const canvasID = "canvas" + name
		document.getElementById(canvasID).innerHTML = ""
		const sim = sims[i]
		sim.helpClasses["canvas"] = true
		sim.Cim = new CPM.Canvas( sim.C, {zoom:3, parentElement: document.getElementById(canvasID) } )
	}
	
	document.getElementById("time").innerHTML = 0
}

function setSliders(){

	for( let i = 0; i < Object.keys( rangeMap ).length; i++ ){
		const sliderID = Object.keys( rangeMap )[i]
		const confID = rangeMap[sliderID]
		if( confID.position == "none" ){
			document.getElementById( sliderID ).value = sims[0].C.conf[confID.key] * 1000
		
		} else {
			document.getElementById( sliderID ).value = sims[0].C.conf[confID.key][confID.position] * 1000
		}
	}
	
	for( let i = 0; i < model_names.length; i++ ){
		const map = modelRangeMap[ model_names[i] ]
		for( let sliderID of Object.keys(map) ){
			const confID = map[sliderID]
			document.getElementById( sliderID ).value = sims[i].C.getConstraint( confID.constraint ).conf[confID.key][confID.position] * 1000
		}
	}
	
	/*document.getElementById("pper").value = sims[1].C.getConstraint("PersistenceConstraint").conf.PERSIST[1] * 1000
	document.getElementById("ldir").value =  sims[1].C.getConstraint("PersistenceConstraint").conf.LAMBDA_DIR[1] * 1000
	document.getElementById("dt").value =  sims[1].C.getConstraint("PersistenceConstraint").conf.DELTA_T[1] * 1000*/
}

function sliderInput(){

	
	for( let si = 0; si < sims.length; si++ ){	
		for( let i = 0; i < Object.keys( rangeMap ).length; i++ ){
			const sliderID = Object.keys( rangeMap )[i]
			const confID = rangeMap[sliderID]
			if( confID.position == "none" ){
				sims[si].C.conf[confID.key] = parseFloat( document.getElementById( sliderID ).value )/1000
			} else {
				sims[si].C.conf[confID.key][confID.position] = parseFloat( document.getElementById( sliderID ).value )/1000
			}
		}
	}
	
	for( let i = 0; i < model_names.length; i++ ){
		const map = modelRangeMap[ model_names[i] ]
		for( let sliderID of Object.keys(map) ){
			const confID = map[sliderID]
			sims[i].C.getConstraint( confID.constraint ).conf[confID.key][confID.position] = parseFloat( document.getElementById( sliderID ).value ) / 1000
		}
	}
	
}

</script>
</head>
<body onload = "initialize(); setPlayPause(); setSliders(); initializeSliders(); step()">

<div style="text-align:center;max-width:1000px;margin:auto">

<h1>Persistent Random Walk Models in the CPM</h1>
<p><br><br><i>This is a work in progress; some debugging still required.</i></p>

<p> Below, we will show side-by-side visualizations of different
variations of persistent random walk (PRW) models in the CPM. Some parameters are shared by
all models, whereas others can be controlled for each model individually.<br><br></p>

<p><b>Shared parameters:</b></p>
<table width="400px" align="center">
<tr>
	<td style="width:20%">T</td>
	<td style="width:5%">0</td>
	<td style="width:70%"> 
		<div class="range-wrap">
		  <input type="range" class="range" min="0" max="1000" id="T" oninput="sliderInput()" >
		  <output class="bubble"></output>
		</div>
	</td>
	<td style="width:5%">10</td>
</tr>
<tr>
	<td style="width:20%">&lambda;<sub>area</sub></td>
	<td style="width:5%">0</td>
	<td style="width:70%"> 
		<div class="range-wrap">
		  <input type="range" class="range" min="0" max="100" id="larea" oninput="sliderInput()">
		  <output class="bubble"></output>
		</div>
	</td>
	<td style="width:5%">0.1</td>
</tr>
<tr>
	<td style="width:20%">Area</td>
	<td style="width:5%">0</td>
	<td style="width:70%"> 
		<div class="range-wrap">
		  <input type="range" class="range" min="0" max="100000"  step = "1000" id="area" oninput="sliderInput()">
		  <output class="bubble"></output>
		</div>
	</td>
	<td style="width:5%">100</td>
</tr>
<tr>
	<td style="width:20%">&lambda;<sub>perim</sub></td>
	<td style="width:5%">0</td>
	<td style="width:70%"> 
		<div class="range-wrap">
		  <input type="range" class="range" min="0" max="100" id="lper" oninput="sliderInput()">
		  <output class="bubble"></output>
		</div>
	</td>
	<td style="width:5%">0.1</td>
</tr>
<tr>
	<td style="width:20%">Perimeter</td>
	<td style="width:5%">0</td>
	<td style="width:70%"> 
		<div class="range-wrap">
		  <input type="range" class="range" min="0" max="200000"  step = "1000" id="perim" oninput="sliderInput()">
		  <output class="bubble"></output>
		</div>
	</td>
	<td style="width:5%">200</td>
</tr>
</table>
<br>

	<div class="row sim-controls">
		<div class="col-12">
			<button id="playPause" class="btn"><span id="playIcon" class="fa fa-play"></span></button>
			<button id="reset" class="btn"><i class="fa fa-redo"></i></button>
		</div>			
	</div>
	<p>
	Time: <span id ="time">0</span> MCS<br></p>

<div align="center">
	<div class="row sim-controls">
		<div class="col-12 col-sm-12 col-md-6 col-lg-4 col-xl-4">
			<h3>MODEL000</h3>
			<p>No persistence, diffusive motion.</p>
			<div id="canvasMODEL000" class="simulationCanvas"></div><br>
		</div>	
		<div class="col-12 col-sm-12 col-md-6 col-lg-6 col-xl-6">
			<h3>MODEL005</h3>
			<p>A PRW based on simple self-reinforcement.</p>
			<div id="canvasMODEL005" class="simulationCanvas"></div><br>
			<table width="350px" align="center">
				<tr>
					<td style="width:20%">P<sub>persist</sub></td>
					<td style="width:5%">0</td>
					<td style="width:70%"> 
						<div class="range-wrap">
						  <input type="range" class="range" min="0" max="1000" id="pper" oninput="sliderInput()" >
						  <output class="bubble"></output>
						</div>
					</td>
					<td style="width:5%">1</td>
				</tr>
				<tr>
					<td style="width:20%">&lambda;<sub>dir</sub></td>
					<td style="width:5%">0</td>
					<td style="width:70%"> 
						<div class="range-wrap">
						  <input type="range" class="range" min="0" max="1000" id="ldir" oninput="sliderInput()">
						  <output class="bubble"></output>
						</div>
					</td>
					<td style="width:5%">0.1</td>
				</tr>
				<tr>
					<td style="width:20%">&Delta;<sub>t</sub></td>
					<td style="width:5%">0</td>
					<td style="width:70%"> 
						<div class="range-wrap">
						  <input type="range" class="range" min="0" max="100000" step="1000" id="dt" oninput="sliderInput()">
						  <output class="bubble"></output>
						</div>
					</td>
					<td style="width:5%">100</td>
				</tr>
				</table>
		</div>			
	</div>
	
	<span style="font-size:90%">Powered by <a href="https://artistoo.net" target="_blank">artistoo</a>.</span><br>
	<br>

</div>



</div>


</body>
<script>
	
	setPlayPause = function(){
		if( sims[0].running ){
			$('#playIcon').removeClass('fa-play');$('#playIcon').addClass('fa-pause')
		} else {
			$('#playIcon').removeClass('fa-pause');$('#playIcon').addClass('fa-play')
		}	
	}
	
	
	function initializeSliders(){
		const allRanges = document.querySelectorAll(".range-wrap");
		allRanges.forEach(wrap => {
		  const range = wrap.querySelector(".range");
		  const bubble = wrap.querySelector(".bubble");
	
		  range.addEventListener("input", () => {
			/*if( range.id == "mact" ){
				sim.C.getConstraint("ActivityConstraint").conf.MAX_ACT[1]=range.value
			} else if ( range.id == "lact" ){
				sim.C.getConstraint("ActivityConstraint").conf.LAMBDA_ACT[1]=range.value
			}*/
			setBubble(range, bubble);
		  });
		  setBubble(range, bubble);
		});
		
	
	}
	
	function setBubble(range, bubble) {
	  const val = range.value;
	  const min = range.min ? range.min : 0;
	  const max = range.max ? range.max : 100;
	  const newVal = Number(((val - min) * 100) / (max - min));
	  bubble.innerHTML = val / 1000;
	
	  // Sorta magic numbers based on size of the native UI thumb
	  bubble.style.left = `calc(${newVal}% + (${8 - newVal * 0.15}px))`;
	}


	
	$(document).ready(function () {
			
		$('#playPause').on('click', function () {
			for( let i = 0; i < sims.length; i++ ){
				sims[i].toggleRunning()
			}
			//sim0.toggleRunning()
			//sim5.toggleRunning()
			setPlayPause()		
		});
		$('#reset').on('click', function () {
			resetSim()
			setPlayPause()
		});
	});
</script>
</html>