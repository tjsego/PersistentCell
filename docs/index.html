<!DOCTYPE html>
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no, user-scalable=no">
  	
<title>PRW</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-wEmeIV1mKuiNpC+IOBjI7aAzPcEZeedi5yW5f2yOq55WWLwNGmvvx4Um1vskeMj0" crossorigin="anonymous">
<script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
<link rel="stylesheet" href="https://pro.fontawesome.com/releases/v5.13.0/css/all.css">
<link rel="stylesheet" href="./style.css">

<script src="./artistoo.js"></script>

<!-- Model scripts -->

<script>
"use strict"

let configJSON = {
	"cpm_temperature" : 0.4 ,
	"cpm_area_c" : 0.016,
	"cpm_area_v" : 79,
	"cpm_nbs_n" : 2,
	"cpm_perim_c" : 0.0222,
	"cpm_perim_v" : 94,
	"len_1" : 100,
	"len_2" : 100,
	"max_time" : 4000,
	"method" : "CPM",
	"model_args" : {
		"MODEL000" : {
			"lambda_dir" : 0.0000000000000000000001,
			"persist" : 0,
			"delta_t" : 10
		},
		"MODEL005" : {
			"persist" : 0.13862943611198905,
			"lambda_dir" : 0.4,
			"delta_t" : 10
		}
	}
}



let config = {

	field_size : [configJSON["len_1"],configJSON["len_2"]],
	conf : {
		torus : [true,true],					
		seed : 1,		
		T : configJSON["cpm_temperature"],			
		LAMBDA_V : [0,configJSON["cpm_area_c"]],					
		V : [0,configJSON["cpm_area_v"]],						
		LAMBDA_P : [0,configJSON["cpm_perim_c"]],
		P : [0,configJSON["cpm_perim_v"]]
	},
	simsettings : {
		NRCELLS : [1],					
		BURNIN : 0,
		RUNTIME : configJSON["max_time"],
		CANVASCOLOR : "eaecef",
		CELLCOLOR : ["CC0000"],	
		zoom : 3,							
		SAVEIMG : false,		
		STATSOUT : { browser: false, node: true },
		LOGRATE : 2
	}
}
/*	---------------------------------- */

let sim0, sim5
let trackMemory = 500, trackResolution = 10


function logStats(){
	let centroid = this.C.getStat( CPM.CentroidsWithTorusCorrection )[1]
	console.log( this.time + "," + seed + "," + centroid.join(",") )		
}

function drawOnTop(){

	// ========= draw direction vectors on top
	
	let pdc = this.C.getConstraint( "PersistenceConstraint" )
	let ctx = this.Cim.context(), zoom = this.conf["zoom"]
	ctx.strokeStyle="#000000"
	let prefdir = ( pdc.conf["LAMBDA_DIR"][ 1 ] > 0  ) || false
	ctx.beginPath()
	ctx.lineWidth = 2*zoom

	for( let i of this.C.cellIDs() ){
		
		// Only draw for cells that have a preferred direction.
		//if( i == 0 ) continue
		if( !prefdir ) continue

		
		function normalize( a ){
			let norm = 0
			for( let i = 0 ; i < a.length ; i ++ ){
				norm += a[i]*a[i]
			}
			norm = Math.sqrt(norm)
			let b = []
			for( let i = 0 ; i < a.length ; i ++ ){
				b.push( a[i] / norm )
			}
			return b
		}
		let cdir = normalize(pdc.celldirections[i])
		
		ctx.moveTo( 
			pdc.cellcentroidlists[i][0][0]*zoom,
			pdc.cellcentroidlists[i][0][1]*zoom)
		ctx.lineTo( (pdc.cellcentroidlists[i][0][0]+5*cdir[0])*zoom,
			(pdc.cellcentroidlists[i][0][1]+5*cdir[1])*zoom)
	}
	ctx.stroke()		
	
	
	document.getElementById("time").innerHTML = this.time
}

function drawBelow(){
	// draw Tracks
	const ctx = this.Cim.ctx
	ctx.globalAlpha = 0.8;
	ctx.strokeStyle="#0000EE"
	ctx.beginPath()
	ctx.lineWidth = 3
	const trace = this.centroids
	if( trace.length >= 2 ){
		let start = [trace[0][0]*this.Cim.zoom,trace[0][1]*this.Cim.zoom]
		ctx.moveTo( start[0],start[1] )
		for( let t = 1; t < trace.length; t++ ){
			let end = [trace[t][0]*this.Cim.zoom,trace[t][1]*this.Cim.zoom]
			if( ( Math.abs( start[0]-end[0] ) < Math.floor( this.C.extents[0]/2 ) ) && ( Math.abs( start[1]-end[1] ) < Math.floor( this.C.extents[1]/2 ) ) ){
				ctx.lineTo( end[0],end[1])
				ctx.moveTo( end[0],end[1])
				start = end.slice()
			} else {
				ctx.moveTo( end[0],end[1])
				start = end.slice()
			}
			//ctx.lineTo(  )
		}
	}

	ctx.stroke()
	ctx.globalAlpha = 1;	
}

function postMCSListener(){
	if( this.time % trackResolution == 0 ){
		const centr = this.C.getStat( CPM.CentroidsWithTorusCorrection )
		const cid = Object.keys( centr )[0]
		this.centroids.push( centr[cid] )
		while( this.centroids.length > (trackMemory/trackResolution) ){
			this.centroids.shift()
		}
	}
	
}

// add a drawOnTop method
let custommethods = {
	drawOnTop : drawOnTop,
	drawBelow : drawBelow,
	logStats : logStats,
	postMCSListener : postMCSListener
}

function initialize(){
	sim0 = new CPM.Simulation( config, custommethods )
	sim5 = new CPM.Simulation( config, custommethods )
	sim0.centroids = []
	sim5.centroids = []
	
	initCanvas()
	
	let pconstraint0 = new CPM.PersistenceConstraint( 
		{
			LAMBDA_DIR: [0,configJSON["model_args"]["MODEL000"]["lambda_dir"]], 
			PERSIST: [0,configJSON["model_args"]["MODEL000"]["persist"]],
			DELTA_T : [0,configJSON["model_args"]["MODEL000"]["delta_t"]]
		} )
	let pconstraint5 = new CPM.PersistenceConstraint( 
		{
			LAMBDA_DIR: [0,configJSON["model_args"]["MODEL005"]["lambda_dir"]], 
			PERSIST: [0,configJSON["model_args"]["MODEL005"]["persist"]],
			DELTA_T : [0,configJSON["model_args"]["MODEL005"]["delta_t"]]
		} )
	sim0.C.add( pconstraint0 )
	sim5.C.add( pconstraint5 )
}


function step(){
	sim0.step()
	sim5.step()
	requestAnimationFrame( step )
}

function resetSim(){
	
	if( sim0.running ) sim0.running = false
	if( sim5.running ) sim5.running = false
	initialize()
	initCanvas()
	setPlayPause()
	sim0.drawCanvas()
	sim5.drawCanvas()
}

function initCanvas(){
	document.getElementById("canvasModel000").innerHTML = ""
	document.getElementById("canvasModel005").innerHTML = ""	
	sim0.helpClasses[ "canvas" ] = true
	sim5.helpClasses[ "canvas" ] = true
	sim0.Cim = new CPM.Canvas( sim0.C, {zoom:3, parentElement: document.getElementById("canvasModel000") } )
	sim5.Cim = new CPM.Canvas( sim5.C, {zoom:3, parentElement: document.getElementById("canvasModel005") } )
	
	document.getElementById("time").innerHTML = 0
}

function setSliders(){
	document.getElementById("T").value = config.conf.T * 1000
	document.getElementById("larea").value = config.conf.LAMBDA_V[1] * 1000
	document.getElementById("area").value = config.conf.V[1] * 1000
	document.getElementById("lper").value = config.conf.LAMBDA_P[1] * 1000
	document.getElementById("perim").value = config.conf.P[1] * 1000
	document.getElementById("pper").value = sim5.C.getConstraint("PersistenceConstraint").conf.PERSIST[1] * 1000
	document.getElementById("ldir").value =  sim5.C.getConstraint("PersistenceConstraint").conf.LAMBDA_DIR[1] * 1000
	document.getElementById("dt").value =  sim5.C.getConstraint("PersistenceConstraint").conf.DELTA_T[1] * 1000
}
</script>
</head>
<body onload = "initialize(); setPlayPause(); setSliders(); initializeSliders(); step()">

<div style="text-align:center;max-width:1000px;margin:auto">

<h1>Persistent Random Walk Models in the CPM</h1>
<p><br><br><i>This is a work in progress; some debugging still required.</i></p>

<p> Below, we will show side-by-side visualizations of different
variations of persistent random walk (PRW) models in the CPM. Some parameters are shared by
all models, whereas others can be controlled for each model individually.<br><br></p>

<p><b>Shared parameters:</b></p>
<table width="400px" align="center">
<tr>
	<td style="width:20%">T</td>
	<td style="width:5%">0</td>
	<td style="width:70%"> 
		<div class="range-wrap">
		  <input type="range" class="range" min="0" max="1000" id="T" oninput="config.conf.T=parseFloat(this.value)/1000" >
		  <output class="bubble"></output>
		</div>
	</td>
	<td style="width:5%">10</td>
</tr>
<tr>
	<td style="width:20%">&lambda;<sub>area</sub></td>
	<td style="width:5%">0</td>
	<td style="width:70%"> 
		<div class="range-wrap">
		  <input type="range" class="range" min="0" max="100" id="larea" oninput="config.conf.LAMBDA_V[1]=parseFloat(this.value)/1000">
		  <output class="bubble"></output>
		</div>
	</td>
	<td style="width:5%">0.1</td>
</tr>
<tr>
	<td style="width:20%">Area</td>
	<td style="width:5%">0</td>
	<td style="width:70%"> 
		<div class="range-wrap">
		  <input type="range" class="range" min="0" max="100000"  step = "1000" id="area" oninput="config.conf.V[1]=parseInt(this.value)/1000">
		  <output class="bubble"></output>
		</div>
	</td>
	<td style="width:5%">100</td>
</tr>
<tr>
	<td style="width:20%">&lambda;<sub>perim</sub></td>
	<td style="width:5%">0</td>
	<td style="width:70%"> 
		<div class="range-wrap">
		  <input type="range" class="range" min="0" max="100" id="lper" oninput="config.conf.LAMBDA_P[1]=parseFloat(this.value)/1000">
		  <output class="bubble"></output>
		</div>
	</td>
	<td style="width:5%">0.1</td>
</tr>
<tr>
	<td style="width:20%">Perimeter</td>
	<td style="width:5%">0</td>
	<td style="width:70%"> 
		<div class="range-wrap">
		  <input type="range" class="range" min="0" max="200000"  step = "1000" id="perim" oninput="config.conf.P[1]=parseInt(this.value)/1000">
		  <output class="bubble"></output>
		</div>
	</td>
	<td style="width:5%">200</td>
</tr>
</table>
<br>

	<div class="row sim-controls">
		<div class="col-12">
			<button id="playPause" class="btn"><span id="playIcon" class="fa fa-play"></span></button>
			<button id="reset" class="btn"><i class="fa fa-redo"></i></button>
		</div>			
	</div>
	<p>
	Time: <span id ="time">0</span> MCS<br></p>

<div align="center">
	<div class="row sim-controls">
		<div class="col-6">
			<h3>MODEL000</h3>
			<p>No persistence, diffusive motion.</p>
			<div id="canvasModel000" class="simulationCanvas"></div><br>
		</div>	
		<div class="col-6">
			<h3>MODEL005</h3>
			<p>A PRW based on simple self-reinforcement.</p>
			<div id="canvasModel005" class="simulationCanvas"></div><br>
			<table width="350px" align="center">
				<tr>
					<td style="width:20%">P<sub>persist</sub></td>
					<td style="width:5%">0</td>
					<td style="width:70%"> 
						<div class="range-wrap">
						  <input type="range" class="range" min="0" max="1000" id="pper" oninput="sim5.C.getConstraint('PersistenceConstraint').conf['PERSIST'][1]=parseFloat(this.value)/1000" >
						  <output class="bubble"></output>
						</div>
					</td>
					<td style="width:5%">1</td>
				</tr>
				<tr>
					<td style="width:20%">&lambda;<sub>dir</sub></td>
					<td style="width:5%">0</td>
					<td style="width:70%"> 
						<div class="range-wrap">
						  <input type="range" class="range" min="0" max="1000" id="ldir" oninput="sim5.C.getConstraint('PersistenceConstraint').conf['LAMBDA_DIR'][1]=parseFloat(this.value)/1000">
						  <output class="bubble"></output>
						</div>
					</td>
					<td style="width:5%">0.1</td>
				</tr>
				<tr>
					<td style="width:20%">&Delta;<sub>t</sub></td>
					<td style="width:5%">0</td>
					<td style="width:70%"> 
						<div class="range-wrap">
						  <input type="range" class="range" min="0" max="100000" step="1000" id="dt" oninput="sim5.C.getConstraint('PersistenceConstraint').conf['DELTA_T'][1]=parseFloat(this.value)/1000">
						  <output class="bubble"></output>
						</div>
					</td>
					<td style="width:5%">100</td>
				</tr>
				</table>
		</div>			
	</div>
	
	<span style="font-size:90%">Powered by <a href="https://artistoo.net" target="_blank">artistoo</a>.</span><br>
	<br>

</div>



</div>


</body>
<script>
	
	setPlayPause = function(){
		if( sim0.running ){
			$('#playIcon').removeClass('fa-play');$('#playIcon').addClass('fa-pause')
		} else {
			$('#playIcon').removeClass('fa-pause');$('#playIcon').addClass('fa-play')
		}	
	}
	
	
	function initializeSliders(){
		const allRanges = document.querySelectorAll(".range-wrap");
		allRanges.forEach(wrap => {
		  const range = wrap.querySelector(".range");
		  const bubble = wrap.querySelector(".bubble");
	
		  range.addEventListener("input", () => {
			/*if( range.id == "mact" ){
				sim.C.getConstraint("ActivityConstraint").conf.MAX_ACT[1]=range.value
			} else if ( range.id == "lact" ){
				sim.C.getConstraint("ActivityConstraint").conf.LAMBDA_ACT[1]=range.value
			}*/
			setBubble(range, bubble);
		  });
		  setBubble(range, bubble);
		});
		
	
	}
	
	function setBubble(range, bubble) {
	  const val = range.value;
	  const min = range.min ? range.min : 0;
	  const max = range.max ? range.max : 100;
	  const newVal = Number(((val - min) * 100) / (max - min));
	  bubble.innerHTML = val / 1000;
	
	  // Sorta magic numbers based on size of the native UI thumb
	  bubble.style.left = `calc(${newVal}% + (${8 - newVal * 0.15}px))`;
	}


	
	$(document).ready(function () {
			
		$('#playPause').on('click', function () {
			sim0.toggleRunning()
			sim5.toggleRunning()
			setPlayPause()		
		});
		$('#reset').on('click', function () {
			resetSim()
			setPlayPause()
		});
	});
</script>
</html>